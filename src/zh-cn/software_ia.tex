\section{人工智能}
如前所述，\doom{} 没有脚本语言。A.I. 基于每种敌人类型的一组状态机，这些状态机直接编译进引擎二进制文件。设计师不需要学习 C，因为他们可以通过文本文件 \cw{multigen.txt} 完全配置敌人。该文本文件由一个工具（狡猾地命名为 \cw{multigen}）解析，并编译为 C 源代码（\cw{info.h} 与 \cw{info.c}）。\\
\par
\rawdrawing{multigen}
\par
% The script has two sections per entity. First the general info and then a serie of state machines. To illustrate here if the imp script.\\
让我们直接进入手写的状态机描述文本，看看 \cw{multigen.txt} 中控制小恶魔（内部称为 \cw{TROOP}）的部分。\\
\par
\tcode{enemy_info.txt}

\tcode{imp_state.txt}

共有四个部分。属性包括 DoomED 的 \cw{id}、\cw{speed}、\cw{height}、\cw{radius}、状态机目标的状态名、声音字符串，以及巨大的 Action 定义。






属性列表和声音名称不言自明，不必花太多时间。更难理解的是状态机的定义方式。\\
\par
一个物体的状态机部分在引擎中静态定义（例如怪物被攻击时直接进入 \cw{seestate}；受到致命伤害时直接进入 \cw{diestate}），部分在 \cw{multigen.txt} 中定义。状态定义中的每一行都遵循以下语法：
\begin{enumerate}
\item 状态名。
\item 帧族（frame family）。
\item 帧 ID（要渲染的精灵）。
\item 持续时间（以 tic 为单位，引擎以每秒 35 个 tic 运行）。
\item 处于该状态时调用的函数。
\item 下一个状态。
\end{enumerate}
\par
\vspace{5pt}
以刚刚生成进入关卡的小恶魔为例，它处于 \cw{spawnstate}，即 \cw{S\_TROO\_STND}。进入状态时，引擎会调用相应函数。在这里，小恶魔会在 \cw{S\_TROO\_STND} 与 \cw{S\_TROO\_STND2} 之间循环。这意味着 \cw{A\_Look} 每 10 个 tic（约 11Hz）会被调用一次。如果发现玩家，\cw{A\_Look} 会把小恶魔置于 \cw{seestate}（也就是 S\_TROO\_RUN1）。\\
\par

假设这个小恶魔运气不好，玩家速度很快，用霰弹枪近距离击中它。此时引擎会把小恶魔置于 \cw{deathstate}（\cw{S\_TROO\_DIE1}）。\\
\par
\tcode{enemy_state_die.txt}\\
\par
注意值 \cw{I}、\cw{J}、\cw{K}、\cw{L}、\cw{M} 对应的精灵名称。\\
\par
\fullimage{imp_die}
\vspace{-10pt}
让我们从这里跟踪状态链：小恶魔在五个步骤中死亡：

\begin{enumerate}
\item 显示第一死亡帧（I）持续 8/35 秒。
\item 显示第二死亡帧（J）持续 8/35 秒，播放 \cw{deathsound} 尖叫。
\item 显示第三死亡帧（K）持续 6/35 秒。
\item 显示第四死亡帧（L）持续 6/35 秒，并标记为非障碍物（\cw{A\_FALL}）。
\item 永久显示第五死亡帧（M）（\cw{-1}）。
\end{enumerate}
\par
整个死亡序列持续 $8+8+6+6=24/35 = 0.68$ 秒。注意如果小恶魔更不走运，被火箭击中，足够的伤害会使其爆裂，进入 \cw{xdeathstate}（\cw{S\_TROO\_XDIE1}）并在 $1$ 秒内死亡。\\
\par
\tcode{enemy_state_xdie.txt}\\
\par
\fullimage{imp_xdie}




\par
\begin{wrapfigure}[9]{r}{0.25\textwidth}
\centering
\includegraphics[width=.25\textwidth]{drawings/sprite_quantization.pdf}
\end{wrapfigure}
引擎使用一套约定来决定渲染时使用哪个精灵。因为敌人不总是正对玩家，所以采用量化方式：相对于玩家的位置，所有朝向被划分为 8 个区间（见图，1 为面向玩家，5 为背向，依此类推）。\\
\par
当处于 \cw{S\_TROO\_XDIE1} 状态时，根据 \cw{multigen.txt}，引擎必须使用精灵族 \cw{TROO} 与帧 \cw{N}。根据朝向（比如小恶魔背对玩家），引擎应使用 \cw{TROON5}。然而 \cw{DOOM.WAD} 中没有这样的精灵（爆裂的敌人总是面向玩家），于是引擎退回使用 \cw{TROON0}（0 表示“始终朝向”的精灵）。\\
\par








\cfullimage{cyber_sprite}{Cyberdemon 在两种“行走”姿势之一的造型。}
\par

Taking a look at one of the frames for the Cyberdemon in figure \ref{cyber_sprite} gives a good idea of the colossal work required from artists. Twelve monsters times eight states times an average of five frames per animation would have required close to 480 drawings (for the monsters only). The power of the NeXTdimension made a tremendous difference in this department.\\
\par
The Cyberdemon however is an extreme case since it is not symmetrical. For the imp, storage is optimized to take advantage of its symmetry. If the engine needs \cw{TROOA6} but doesn't find it in the \cw{WAD}, it uses its opposite (\cw{TROOA4}) and draws it mirrored.\\ 
\par
\trivia{You may have noticed that in the list of states there is a non-obvious one named \cw{RAISE}. This is used when the Arch-Vile resurrects dead monsters. The animation plays the death animation in reverse. Note that there is no reverse gib sequence, but the Arch-Vile still revives gibbed monsters using a reverse normal death animation.}



\begin{figure}[H] \centering
\cscaledimage{0.9}{imp_sprite}{}
\end{figure}
\par
\trivia{When an entity receives more than  \cw{spawnhealth} damage (negative its spawning state; in the case of an imp that would be -60), the engine triggers not \cw{deathstate} but the \cw{xdeathstate} state that means the entity exploded.}\\
\par 
\ccode{explode.c}





\cw{multigen.txt} is compiled to the humongous 5000 line \cw{info.c} containing an array of \cw{state\_t}s holding the state machine, and an array of \cw{mobjinfo\_t}s containing the thing properties.\\
\par
\ccode{enemy_state_compiled.c}\\
\par
\begin{wrapfigure}[9]{r}{0.5\textwidth}
\centering
\includegraphics[width=.5\textwidth]{drawings/automate.pdf}
\end{wrapfigure}
Not all automaton state changes can be inferred from the transition array. In the case of the imp, transitions are partly dictated by the logic in \cw{info.txt} (black arrows) and partly dictated by the game engine (direct to red state).\\
\par
 In the state diagram, the engine-triggered transitions to \cw{pain}, \cw{die}, and \cw{xdie} are not represented since these states can be reached directly from any other state.
\par
%In the diagram, note the starting state (\cw{SPAWN}) and the only final state \cw{XDIE}. \cw{DIE} can transition to \cw{RAISE} thanks to the Archville heal power which makes the dead rise. The only way to make sure a monster will never come back is to gib it.

\pagebreak

\subsection{Optimization}
Monsters constantly request collision tests. Even the simple \cw{SPAWN} state, for which a two frame animation cycles repeatedly (monsters do not have a standing script, they "walk on the spot"), calls the \cw{A\_Look} function to attempt to locate the player. Furthermore, once activated, monsters need path-finding and range attack tests. The calculations proved to be an unacceptable level of load on the CPU. Even using the blockmap structure to speed up collision detection it still meant hundreds of rays to cast, thirty five times per second which resulted in thousands of instructions.\\
\par
To solve this problem, another data structure was introduced with \cw{doombsp}. Each sector visibility is precomputed to allow impossible collisions to be rejected early. The visibility data is stored in a bit array\footnote{This approach later morphed into the Potentially Visible Set which was instrumental to Quake engine.}. This dataset is packed into a matrix of size $num\_sectors^2/8$ and stored in a \cw{REJECT} lump. At runtime, the engine compares the player's current sector with a monster's sector to potentially bypass sight detections for this monster entirely.\\
\par
\drawing{reject_explained}{}
% Regardless of the monsters, the base state machine looks like this but it tuned based on custom functions called in some states (e.g: \cw{A\_SpidRefire}, \cw{A\_CyberAttack}, and \cw{A\_BrainExplode}).\\
% \par
% \pngdrawing{automate}{}
\vspace{-7pt}
Figure \ref{reject_explained} features four sectors with five monsters and one player in sector \circled{A}. The engine needs only to run expensive line of sight calculations for the monster in sector \circled{B}. All four others monsters are "rejected" via a cheap lookup. The table is only used for sight. Monsters will still hear the player since sound is cheaper to propagate.\\
\par
\trivia{With "unlimited" CPU power, modern "node builders" don't build \cw{REJECT} anymore.}






\section{Map Intelligence}
Despite lacking a scripting system, maps still managed to offer a rich experience. They were full of surprises with numerous elements interacting with the player. Switches and tripwire-enabled doors, secret passages, elevators, crushing walls, traps and more.\\
\par
\drawing{E1M1_tripwire}{UDOOM's E1M1 features 21 special lines and five of them open secret areas.}
\par
All interactions are achieved via a simple association between a line's \cw{special} attribute which designates one action to perform and a \cw{tag} value that indicates the target sectors to act on.\\
\par
The list of action types is impressive -- there are more than 130 of them: open/close door at normal/turbo/blazing speeds; raise/lower floor and ceilings; fast ceiling crush \& raise; stairbuilders; locked door so you are trapped with monsters; lighting level effects; raise floor to nearest height, texture changes, teleports, level normal and secret exits, and many others.\\
\par
The tag designating the target is any number picked by the designer. Any sectors the designer wants to be targeted by this action are tagged with the same number. With this system, a line can trigger only one action but target several sectors.\\
\par
\trivia{The first maps designed had mostly orthogonal walls and military design. It took the team a few months to realize \doom{} engine was capable of much more.}
\pagebreak






\begin{wrapfigure}[17]{r}{0.5\textwidth}
\centering
\includegraphics[width=.5\textwidth]{drawings/E1M3_trap.pdf}
\end{wrapfigure}
Who doesn't recognize E1M3's hunt for the blue key on page \pageref{e1m3_trap}? After traversing the whole map, it is finally found sitting on a pedestal, guarded by only two low-level opponents which are easily dispatched.\\
\par
But as soon as the player picks it up, the lights go out and the sound of a door opening and growling imps can be heard. It was a trap the player just walked into and imps are just behind (page \pageref{e1m3_trap})!\\
\par
To implement this effect, two sets of lines were used. The first lines (in blue) target the door sector behind which the monsters were hiding and opens it. The second lines (in red) target the current sector and set its light level to "very dark".\\
\par



\par
\begin{wrapfigure}[23]{l}{0.5\textwidth}
\centering
\includegraphics[width=.5\textwidth]{drawings/E1M3_sides2.pdf}
\end{wrapfigure}
Another interesting effect in E1M3 is the rising staircase that leads to a small room containing the exit to level 4. It is implemented by having a line with the "BuildStairs" (\#8) type targeting the first step sector with its tag. The engine has a hardcoded \cw{EV\_BuildStairs} function that looks up the target sector via the tag then uses a flood-fill algorithm.\\
\par Adjacent sectors are repeatedly looked up and a bit more height is added with each iteration. To avoid raising the whole level, the algorithm stops when the next sector's texture is different from the last elevated sector, which explains why the stairs are gray, while the top and bottom surrounding them are dark brown.\\
\par
Before and after screenshots can be seen on page \pageref{stairs}.


\fullimage{Doom-E1M3-Ingame2.png} \label{e1m3_trap} \\
Finally, the blue key (above)! Nooo, it's a TRAP (below)!

\vspace{2mm}
\fullimage{Doom-E1M3-Ingame3.png}
\fullimage{e1m3_after_stairs.png} \label{stairs} \\
Above, all steps start at the same level. Below, after the "BuildStairs" trigger. 

\vspace{2mm}
\fullimage{e1m3_before_stairs.png}



\section{Game Tics Architecture}
With the knowledge of how opponents and map elements work, we can pick up the code where we left it with regard to game simulation on page \pageref{TryRunTics.c}. \cw{G\_Ticker} is where all thinkers are run.\\
\par
\ccode{G_Ticker.c}
\par
Most of the meat is in the 3D gameplay (\cw{P\_Ticker}) function.\\
\par
\ccode{P_Ticker.c}
\par
\cw{P\_PlayerThink} is where the player "thinks". This function consumes the \cw{ticcmd\_t} (which we already studied on page \pageref{cmd_t_type}) and controls where the player moves and fires.\\
\par 
\cw{P\_RunThinkers} is how the map and monsters "think". Anything that must occur over more than one frame is placed in a thinker object and stored in a doubly-linked list. Thinkers are structs with a function pointer and some data for the function pointer parameters. Each gameplay tic, every thinker in the list "thinks". When thinkers are done thinking they set their function pointer to -1 and are dropped from the list. Note that doors have no feelings but they are nonetheless "thinkers" too.\\
\par
\cw{P\_UpdateSpecials} takes care of animating special textures such as water, or animated walls. It also takes care of switching the texture when a button is pushed.\\
\par 

 \cw{P\_RespawnSpecials} respawns medikits, weapons, and ammo in deathmatch.



\ccode{thinker_t.c}\\
\par
C has no OOP capabilities yet the engine managed to implement a polymorphism system. Semantically, \cw{think\_t} structs are stored in the linked list element (\cw{thinker\_t}) with no space for the payload. \\%But since all thinkers start with a function pointer, the engine stores the function pointer and the data parameter payload with a single pointer. \\
\par
\ccode{floormove_t.c}\\
\par
\cw{EV\_BuildStairs}, which creates thinkers to build stairs, shows how to use the system.\\
\par
\ccode{EV_BuildStairs.c}\\
\par
This is a pretty cool mechanism. While iterating over the list of \cw{thinker\_t}, the loop simply calls \cw{thinker->function(thinker)} which has no knowledge of either the function called or the payload involved.
