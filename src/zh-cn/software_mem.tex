\section{Zone 内存管理器}
和当时所有游戏引擎一样，\doom{} 不信任标准 \cw{malloc}，连 Watcom 提供的 \cw{libc} 里的也不信。原因是标准分配器会导致内存碎片，进而威胁引擎的稳定性。它们在小分配上也很浪费，因为优化目标是大块分配，而这并不是引擎的需求。它们缺乏良好的调试工具来跟踪泄漏与缓冲区溢出。最后，它们还缺乏可移植性。因此 \doom{} 使用自己的内存管理器。\\
\par

\trivia{引擎在一个明确的内存预算下运行。在 \NeXT 上启动时，内存管理器只分配 4 MiB 的 RAM，一字节都不多，以确保宣称的最低 4 MiB 配置足够。在 DOS 上，内存管理器会检查机器至少有 4 MiB，并在可用时使用最多 8 MiB，以改善缓存保留。}\\
\par
内存管理器的最初版本基于“Zone”。每个 zone 都有一个内存池可用于分配 RAM。这个设计让分配器得名“zone allocator”，前缀是 \cw{Z\_}，文件名为 \cw{z\_zone.c}。后来多 zone 的想法被放弃（可能是因为 DOS/4GW 统一了 RAM），改为单一 zone 内的块链结构。不过 “Zone” 这个名字很酷，就保留了下来。\\
\par
看看代码里的 \cw{struct} 可以理解内存管理器如何工作。\\
\par
\ccode{memblock_t.c}\\
\par
内存分配器只使用一个 zone 来覆盖所有可用 RAM。这个“主”zone 是由块组成的双向循环链表。一个块如果有 \cw{**user} 值，就表示已占用；如果 \cw{user} 为 \cw{NULL}，则表示空闲。任何时刻，这条块链都追踪着机器上的所有 RAM。



每个块都有一个清理提示（purge hint），这样分配器在处理分配请求时就知道是否可以释放这个块。\\
\par
\ccode{memory_zone.c}\\
\par
初始状态（假设总 RAM 为 8000 字节）时，所有 RAM 都在一个单独的块里，该块标记为 \cw{STATIC}。它的 \cw{user} 为 \cw{NULL}，表示空闲；\cw{size} 为 8000 字节；\cw{next} 与 \cw{prev} 都指向自己。rover 指向唯一的块。\\
\par
\rawdrawing{zalloc_start}
\par
每次调用 \cw{Z\_Malloc} 时，rover 会寻找足够大的空闲块。找到后，它会创建一个新块并缩小空闲块。两次大小为 1000 和 3000 的分配会得到链中的三个块。注意默认的 \cw{user} 值（2），稍后会解释。\\
\par
\rawdrawing{zalloc_allocs}

最终，分配器会收到一个请求，其大小超过 rover 指向的“空闲”块所能提供的大小。在下面的配置中，空闲块只有 500 字节。任何大于该大小的请求都会失败。\\
\par
\rawdrawing{zalloc_fail}
\par
为满足内存请求，rover 会先标记当前位置并扫描寻找足够大的空闲块。如果 rover 绕回到原位置，说明没有足够大的空闲块可以满足请求。此时引擎会报错并终止。\\
\par
很可能发生的是，一些块在此期间已通过 \cw{Z\_Free} 释放。块被释放时，\cw{user} 会被设回 \cw{NULL}，并且相邻的空闲块会合并。假设块 B 和块 C 被释放，它们会合并成一个空闲（\cw{owner=NULL}）且大小为 5000 字节的块。\\
\par
\rawdrawing{zalloc_freed}
\par
要分配 1KB，rover 会“绕回”，发现这个空闲块并用它来分配块 \cw{E}。\\
\par
\rawdrawing{zalloc_saved}
\par
还有第三种情况更值得关注。到目前为止，我们只谈到像 \cw{STATIC}、\cw{MUSIC} 或 \cw{LEVEL} 这样的静态分配块。但还有一种标签属于“可清理（purgeable）”类别。\\
\par
它主要由下一节介绍的 WAD/lump 管理器使用。如果一个块标记为 \cw{PU\_CACHE}，意味着引擎此刻不需要该数据，但将来可能需要；不过内存分配器被允许释放它。在下面的配置里，没有任何块能成功分配 1000 字节。\\
\par
\rawdrawing{zalloc_cache_before}
\par
rover 会沿着链找到块 \cw{F}，释放它（即便它有 owner）并使用它。结果是一个新的块 \cw{G}，后面跟着一个大小为 3000 的空闲块。\\
\par
\rawdrawing{zalloc_cache_after}
\par
与 libc 的 \cw{malloc} 相比，这个内存管理器还有很多其他特性。字段 \cw{id} 用作金丝雀标记来检测内存溢出（值应始终为 \cw{ZONEID}）。\cw{Z\_Free} 能检测双重释放等误用情况。通过 \cw{Z\_DumpHeap} 的转储系统可用于检查内存。甚至还有完整性检查器 \cw{Z\_CheckHeap}，用于验证每个块是否“触碰”下一个块，以及不存在两个连续的空闲块。\\
\par
\trivia{块可以通过 \cw{Z\_ChangeTag} 重新标记。引擎在处理资源时经常以 \cw{PU\_STATIC} 标签分配内存块，完成后再改为 \cw{PU\_CACHE}。这样在需要时可以释放内存，同时如果该块仍在 RAM 中，则可能避免再次从硬盘读取。}
% \trivia{分配器代码并不完全在 DOS 与 \NeXT 之间通用。RAM 系统需要提供 \cw{I\_ZoneBase}。\\
% \par \tcode{zone_undefined.txt}}
% \par
%\trivia{Dave Taylor 有自己的 TAG：\cw{PU\_DAVE}，意思是“Dave 认为需要静态的其他任何东西”，但这个标签从未被使用。}

\pagebreak
