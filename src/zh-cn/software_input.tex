\section{输入}
输入系统基于“事件”的概念进行了抽象——当子系统采样设备时生成事件——并由核心中的响应器来消费这些事件。按键、手柄状态和鼠标输入都存储在 \cw{event\_t} 结构中。\\
\par
\ccode{events.c}
\par
核心系统会在新的一帧开始或新的游戏 tic 开始时通知输入系统，给它机会采样设备输入、封装成 \cw{event\_t}，并通过回调函数把事件投递到核心事件缓冲区。\\
\par
\begin{figure}[H]
\centering  
\begin{tabularx}{\textwidth}{ L{0.6}  L{1.4}}
  \toprule
  \textbf{函数} &  \textbf{用途}\\
  \toprule 
  I\_StartFrame & 核心在渲染视觉帧之前调用。\\
  I\_StartTick & 核心在渲染游戏 tic 时调用。\\
  
  D\_PostEvent & 输入系统调用，用来向核心发送事件。\\
   \toprule
\end{tabularx}
\caption{\doom{} 的输入系统接口}
\end{figure}
\par
事件通过一个大胆地命名为 \cw{events} 的环形缓冲区存储在核心中。\\
\par
\ccode{events_storage.c}

\par
在每个游戏 tic 上，事件队列都会被清空。事件会沿着一条响应器链逐个传递\footnote{“响应器”架构很可能受到了 NeXT 的 \cw{AppKit} 框架中 \cw{NSResponder} 元素的影响。事实证明这是一个很稳健的设计，直到今天仍在使用。}。每个响应器都可以选择忽略事件，此时事件会继续向下传递。\\
\par
\ccode{D_ProcessEvents.c}\\
 \par 如果事件被消费（在代码里称为“吃掉”），它就不会再传给后续响应器。注意 3D 渲染器是链条中的最后一个响应器。\\
 

\begin{wrapfigure}[12]{r}{0.45\textwidth}
\centering
\scaledimage{0.45}{cyberman2.png}
\end{wrapfigure}
\trivia{文件 \cw{i\_cyber.c} 与名为“Cyberdemon”的敌人无关。它是一个专门为 Logitech 在 1992 年左右制造的奇特设备“CyberMan”写的驱动。它是一种提供六自由度的混合输入设备，可以把它想象成一个上面装着鼠标的摇杆。对其 \cw{SWIFT} API 的支持似乎是后来才加上的，因为它不像键盘、鼠标和摇杆那样生成事件，而是直接在 tic 命令流中生成 tic 命令。}\\
\par
大多数响应器会直接以原始 \cw{event\_t} 形式消费事件，但 3D 渲染器会把它们规范化为 \cw{ticcmd\_t}，其中包含的不是输入，而是玩家动作。这些所谓的“命令”没有时间戳，因为它们属于以固定 35Hz 频率运行的游戏逻辑流。 \\
\par
\ccode{ticcmd_t.c} \label{cmd_t_type}
\par
“命令”这种设计模式解锁了许多功能。 \\
\par
命令当然会被 3D 引擎消费，但在录制演示（demo）时，它们也可以存盘。之后可以把它们重新注入引擎，重放完全相同的游戏过程。这个系统的妙处在于，即便玩家的电脑帧率不同，也能互相交换回放。\\
\par
这让 \doom{} 拥有了类似街机的演示功能。\cw{DEMO1}、\cw{DEMO2} 和 \cw{DEMO3} 这些 lump 都是以 35Hz 播放的 \cw{ticcmd\_t} 流。由于只存储命令且游戏是确定性的，demo 文件非常小，每秒只需 $ 8 * 35 = 280 $ 字节。\\
% \par
% 结构 \cw{ticcmd\_t} 在多人网络模式下会原样在网络上传输。
% \par

\scaleddrawing{1}{event_arch}{}
\par
把一切放在一起，\circled{1} 核心每帧调用一次输入系统、每个游戏 tic 调用一次，让其采样设备。\circled{2} 事件发送到核心。\circled{3} 收到的事件存入环形事件缓冲区。\circled{4} 事件分发给各个响应器。如果 3D 渲染器处于活动状态，事件会被合并成 \cw{ticcmd\_t}，可以被消费、发送到网络，或在录制 demo 时写入磁盘。\\
\par
在 demo 回放期间，输入系统会被禁用；tic 命令从磁盘读取并注入管线。
