\qaq{能不能简单介绍一下你的背景，比如在为 SNES 开发 \doom{} 时你多大年纪等？}
\qaanor{DOOM/FX 于 1995 年发布，当时我 25 岁。我是在加州圣迭戈完成它的，但我是加拿大人，出生并成长于安大略省多伦多。我的第一个程序在我 13 岁时就发表了。以下是我做过的一些项目：
	\begin{itemize}
      \item Bubbles —— 一款面向 Commodore 64 的类 Centipede 游戏。
      \item The 64 Emulator —— 一款在 Amiga 上模拟 Commodore 64 的程序。
      \item Dragon's Lair —— 另一款 Amiga 程序，是家用电脑上首个全屏、全彩动画游戏——它也是首个在游戏过程中实时从六张软盘流式读取数据的游戏！
      \item DOOM —— 一款在 Super Nintendo 上运行的热门“2-$\nicefrac{1}{2}$D”第一人称射击版本，基于专为 Argonaut Software（英国）设计的 SuperFX RISC 处理器（又名“GSU2A”）而打造的原创引擎。SNES 版 DOOM 是少数能兼容大多数 SNES 硬件外设（鼠标与光枪）的游戏之一。它还支持 XBAND 硬件调制解调器，两名玩家可以在 SNES 上完成真正罕见的在线对战。我搭建了一套定制开发系统（汇编器、链接器、调试器等），使用改造过（也就是拆改过）的《星际火狐》卡带提供 CPU，并通过串行接口与基于 Amiga 的工具链通信——该接口插在 SNES 的两个手柄口上。后来由于 GSU2A 的官方硬件开发系统才加入支持，因为当时还没有游戏发布可以拿来“改造”使用（《星际火狐》使用的是原始 GSU，时钟只有 GSU2A 的一半，并且内存更小，硬件也有其他差异与增强）。
      \item “Bleem!” 是一款面向 PC 的 PlayStation 模拟器——程序完全用 x86 编写。我逆向了 PlayStation 的软硬件，写了可在运行时优化的重编译器来处理游戏逻辑，并加入了更高分辨率与 3D 显卡支持等 PC 端增强。
      \item Dreamcast 版 “Bleem!” 是一款完全用 SH4 编写的 PlayStation 模拟器。我作为唯一发明人获得了四项专利，涵盖了我为 bleem! 及 Dreamcast 版 bleem! 开发的技术与方法。
      \item Cyboid 是一款高速 3D FPS（第一人称射击），支持单人/双人分屏，以及最多八人在线多人模式——想想“Quake”，差不多就是那样。它支持 VR、应用内购买、成就与排行榜、多家广告中介，以及最多八人在线联机。它可运行在 Google 与 Amazon 的多平台上。游戏用 ARM 汇编、原生 C/C++ 与 Java 编写，整个包（代码、数据、图形、声音与音乐）只有 8MB（……比现在游戏/应用里一张纹理还小！）。这些自定义引擎都高度优化以支持尽可能广泛的设备，包括较低功耗的硬件（例如 Amazon Fire TV Stick）或运行 Android API 17“Jellybean”的旧设备。
     \end{itemize}
     }
 



\qaq{GSU-2 似乎无法渲染全屏。我读过一些网上的说法，有人提到硬件限制把处理器限制在 192 行，有人提到与 DMA（从 GSU RAM 读取）相关的带宽问题。你能提供更多见解吗？}
\qaa{如你所知，Super NES（“SNES”）是一种基于字符的图形架构，它使用“字体”来定义每个字符的图像，并使用“映射”来指定屏幕上每个位置显示什么字符。\\
\par
 实际上，“Super/FX”（又名 GSU “Graphics Support Unit”）通过快速的定制硬件与针对图形处理优化的指令集组合，在 SNES 上实现了位图仿真。\\
\par
 GSU 是 Jez San 与 Argonaut Software 设计的极其出色的定制 RISC 芯片——这是我最喜欢的硬件架构之一，尤其是它的指令既优雅又简单，而且整个设计非常像 ARM 处理器（这也是我另一个最喜欢的硬件体系）。\\
\par
 顺便说一句，我 100000\% 同意 Jez 对 GSU 的评论——完全正确！！！\\
\par
 原始 GSU（用于《星际火狐》）运行在 10.74 MHz，而 DOOM/FX 使用的 GSU/2A 运行在 21.48MHz。\\
\par
 它支持所有标准 ALU 操作（加、减、异或等），还有一系列快速乘法操作、多个内存载入/存储操作（取决于访问 ROM 还是 RAM）、“LOOP” 指令以及 “PLOT” 指令。代码可以从 ROM、RAM 或板载 512 字节缓存运行（DOOM/FX 大量使用了它！）\\
\par
 GSU 真正特别的是它的大寄存器组（16 个通用寄存器，而 65816 只有更少）以及指令前缀 “FROM/TO/WITH”，允许你指定源寄存器（“FROM”）与目标寄存器（“TO”），或使用 “WITH” 在同一寄存器上操作——这种方式现在很常见，尤其在 ARM 架构上，但当年既独特又强大！\\
\par
 对我来说，带宽从来不是问题——以下是两个例子：
\begin{enumerate}
\item “PLOT” 指令使用 “X”“Y” 坐标和 “COLOUR” 写入模拟位图，可以一次更新单个像素。我写过代码测试 PLOT 的执行速度，发现由于底层内存仍然是字符阵列，每次“绘制”到一个新的字符“行”（宽 8 像素）时，硬件会把该字符的内存（基本上是 8 个字节，构成 256 色“平面”）读入内部缓存，于是后续对同一字符“行”的绘制会快得多。


我在 DOOM/FX 中利用了这一点：第一次写入“新行”时，我会“预写”多个像素——也就是说，不是一像素一像素地写，而是用同一颜色写多个像素，让硬件迅速更新内部的“字符行”缓存，然后再用正确的颜色高速覆盖这些像素（通常每像素只需 1 个时钟！）

 

\item GSU 的速度远快于 SNES 的 65816，大部分游戏代码（接近 95\%）都是 GSU 代码——65816 基本上只是等待各种中断来更新内存、切换屏幕、读取手柄等——除此之外几乎是空闲的！
\end{enumerate}
 

GSU 有四种不同的渲染高度（128、160 和 192 像素），还有一个用于精灵的 “OBJ” 模式，以及三种像素“深度”选项（4、16 或 256 色）。\\
\par
 DOOM/FX 使用的是 192 像素 / 256 色模式。\\
\par
 还有一件多数人不知道的事：DOOM/FX 是制造成本第二高的卡带，因为它包含 GSU/2A，拥有当时最大的 ROM（2MB）和 RAM 配置，还用了定制的红色塑料卡带……唯一缺的就是电池备份！}









\qaq{我猜你用了 Unofficial Doom Specs 来提取所有资源，对吗？}
\qaa{我使用了各种在线资源来逆向 DOOM 的数据格式——如果没有其他人做的大量工作，DOOM/FX 不可能在这么短的时间内完成！}

\qaq{你能概述一下 Reality 引擎吗？我猜你用了 BSP，但也做了类似 visplanes 的东西吗？}
\qaa{Reality 引擎基本上是一个高度定制的 2-$\nicefrac{1}{2}$D 游戏引擎，几乎全由 GSU 代码编写。所有代码都被设计成小块运行，以便装入 GSU 的内部高速缓存。它的架构类似 DOOM，使用 2D BSP、扇区、线段等——其中有许多优化可以尽量减少计算出“该绘制什么”的处理量。}

\qaq{你有从 id Software 得到任何帮助吗？}
\qaa{我在有一个完全可运行的原型时就向 Sculptured Software 演示了游戏——包含图形、贴图、移动、敌人等——只要看一眼就知道那是“DOOM”。\\
\par
几周后 id Software 也看到了游戏，虽然只是早期版本，但它已经比常见的原型或“概念验证”成熟得多，因此他们能提供的帮助不多。\\
\par
当然，要让游戏发布仍有大量工作要做……比如声音、音乐、剩余关卡、测试等等——最终是在 Sculptured Software 多位同事的帮助下把游戏做完的。}

\qaq{搭建工具链用了多久？然后写游戏代码用了多久？ }
\qaa{据我记得，游戏大约开发了八个月，前后可能有些出入。游戏制作过程中使用了多个工具链来处理图形、声音和数据……\\
\par
代码是用我写的定制开发系统完成的，其中包括汇编器、链接器、源级调试器等——我在多个项目（NES、SNES 等）中都用过这个系统，它是多年累积的成果。为 SuperFX 增加支持只花了几周时间。我还写了许多工具和实用程序，用于从 PC 版游戏中提取原始资源并转换成 Reality 引擎优化的格式。声音和音乐使用的是 Sculptured Software 的工具链，所以我只需要把提取的资源转换成合适的格式供处理即可。}

\qaq{你是怎么联系发行商的？在 Sculptured Software 接受之前你试过其他发行商吗？}
\qaa{Sculptured Software 是我唯一考虑过的发行商——我在 Sculptured 工作过几年，认识很多人——他们都很棒！}

\qaq{当时任天堂的“禁止暴力、禁止流血”政策很难遵守吗？}
\qaa{ Nintendo 非常好合作——要求很少、改动很少，提交流程也很简单。}

\qaq{回顾这款游戏/这段人生，你还有什么想说的吗？（有人感叹如今编程更复杂，但我觉得当年更难，甚至连编程手册都难找。）}
\qaa{ 依我看，如今的编程和“旧时代”非常不同……\\
\par
 为单一硬件（如 SNES）写程序要容易得多——你可以把时间花在游戏上、花在性能优化上。\\
\par
Commodore 64、Amiga 与 Sega Dreamcast 也是如此——每个平台都有独特的技术特性与进步，给了你很多机会去做出与众不同的东西，而现在就很难做到了……\\
\par
相比之下，写一个 Android 应用有太多工作量，原因很多，且多数不受开发者控制……\\
\par
 你要面对非常多的硬件（有很多关于图形、声音、输入等方面的支持差异），还有多个 OS 版本（每个版本都有自己的“怪癖”、限制、差异与变化）。尽管 Google 提供了 Firebase 与 Google Play 等完整组件，这当然很好，但频繁的更新、变化与差异仍然让你要花大量时间与成本才能让应用保持“最新”。\\
这些年制作一个能跑在多种 Android 设备上的简单“应用”很轻松，甚至很容易……但要写一个尽可能利用众多设备独特特性的东西，则需要大量时间、资源与精力——我认为这也是为什么如今有那么多相似的游戏、应用和作品——当然，其中也有不少独特之处，但远不如过去——我们已经不再看到像 “Lode Runner”“Archon” 或 “Sword of Sodan” 这样的作品了。\\
\par
最近有位朋友推荐了一款 FPS，下载量超过 1GB！……然后这游戏还需要持续联网来更新、下载资源，甚至才能玩……我们从 Amiga 上的《Dragon's Lair》——一个 8K 程序加 5MB 数据的时代，走到了今天。}



\b{关于 GSU-2 工作方式的更多信息：}\\
\qaa{基本上，GSU 在自己的 RAM 里生成位图，然后再传输到 SNES 的 PPU 进行显示。我认为没有足够的时钟周期与 RAM 在不出现撕裂/故障的情况下及时生成并传输整屏数据。GSU RAM 同一时间只能被一个设备访问（要么 GSU，要么 SNES），不能同时访问……所以你必须先在 GSU RAM 中生成数据，然后传输到 SNES 端的 PPU（“Picture Processing Unit”）上显示。传输期间，SNES 端可访问 RAM，而 GSU 不能，所以必须等传输完成后才能让 GSU 生成更多数据。不过 GSU 仍然可以在不访问内部 RAM 的情况下做很多事——DOOM/FX 就大量利用了这一特性。顺便说一下，ROM 也是同样的道理——同一时间只能被一个设备访问，要么 GSU，要么 SNES。}

\b{DOOM SNES 开发轶事：}\\
\qaanor{
\begin{enumerate}
\item   有一次，Sculptured 的一位开发者修改了很多基础关卡——添加了很不错的改动，比如物体摆放等——但在把新关卡展示给 id Software 后，他们基本希望游戏尽可能还原原作……于是我们撤回了所有改动，尽量保持原始关卡，只做最少修改。

        id Software 允许我保留的一件事是自动旋转的俯视地图。

\item     引擎有不少可配置选项——其中很多最终没有用上……例如：
\begin{enumerate}
        \item      墙面可以以单像素而不是双像素绘制，但没有足够的时钟周期保证可接受的帧率。
        \item      地板也可以绘制——单像素或双像素——但 ROM 容量不足以存储纹理，而使用颜色/抖动更快。
\end{enumerate}
\item    用于生成显示的时序与逻辑相当复杂……如下所示：

        我基本上把显示分成“三份”来生成，因为 GSU 和 PPU 的 RAM 太有限。

        “PPU” 是 SNES 端的 “Pixel Processing Unit”——基本上是负责读取内存并把画面显示在屏幕上的硬件部分。

        每“一份”基本上分为三个“步骤”生成：
        \begin{enumerate}
                \item 计算所有必要的数据等。
                \item 在 GSU RAM 中生成图形输出。
                \item 将 GSU RAM 传输到 PPU。
        \end{enumerate}
        PPU 的内存不足以存放两整帧画面（当前帧和下一帧）……

        为了解决这个问题，我把 SNES 端的 PPU 内存分成五个“部分”，其中三个用来显示一帧（显然，PPU 需要访问这些数据才能把画面显示出来）。

        剩下的两个“部分”用于存储下一帧的第一和第二“三分之一”……但最后一份怎么办？

        下一帧的最后一份更复杂，因为它将覆盖到 PPU 正在显示当前帧的“活动”三分之一之一！

        当 GSU 完成最后一份的生成后，我会等待一个光栅中断，确保 PPU 不在显示用于“共享”三分之一的区域，然后在光栅扫到该屏幕区域前把最后一部分覆盖过去。

        最后一次传输完成后，我重新配置这五个区域中哪几个由 PPU 用于显示新的游戏帧，然后重新开始整个过程：在现在可用的两个区域中生成下一帧，并以相同方式更新最后三分之一。 

        当然，如果游戏能以 60fps 运行，我就可以直接即时生成全部内容，不需要这么复杂的代码！

        声音也有些棘手，原因类似……但复杂度没那么高。RAM 不足以存放所有音效，所以例如武器声音会在你切换武器时动态传输——在“切换武器”动画播放时，有足够时间把该武器的声音数据传入，但 SPU（声音处理单元）里一次只能放一个武器音效。

\item     大多数图形（纹理、物体等）都以压缩形式存储，并在绘制时解压。

        我使用了一种简单的编码来降低内存需求，而 GSU 足够快，因此在处理周期与存储之间做这样的权衡是合理的。
\end{enumerate}
        }
