\section{网络}



尽管 \doom 的 3D 渲染令人惊艳，但真正把它推向另一层次的是网络能力以及著名的死亡竞赛。能够连接两台 PC 并与真人玩家互动，是大多数玩家从未见过的事情。开发早期就显而易见，这个方面会非常惊人。\\
\par
\fq{我仍然记得 Doom 的多人模式刚刚勉强能跑起来的那天。我在办公室里除了我的 NeXT 工作站，还摆了两台 DOS 机来测试多人联机。IPX 网络在系统之间转发用户输入，但没有错误恢复，所以非常脆弱。尽管如此，我可以在测试关卡里生成两个海军陆战队员，他们能互相看着对方。\\
\par
我在一台机器上左右平移，同时转头看另一台电脑，看到那个海军陆战队员精灵在另一名玩家的手枪前左右滑动。我让它滑到屏幕中央，然后转向另一台电脑。“砰！”“呃！”抽搐。挪动。大大的笑容。:-) “砰！”“砰！”“砰！”“砰！”在真正记录下第一击杀之前就发生了同步失败，但已经显而易见这将非常棒。}{John Carmack, kotaku.com “Memories Of Doom”}\\
\par


\vspace{-20pt}
\subsection{架构}

现代 FPS 大多采用客户端/服务器网络架构，有多个客户端和一个作为事实来源的服务器。客户端可以随时加入游戏、把命令发送给服务器、接收世界更新，并通过预测来最小化通信延迟。\\
\par
\begin{wrapfigure}[12]{r}{0.4\textwidth}
\centering
\includegraphics[width=.4\textwidth]{drawings/p2psvg.pdf}
\end{wrapfigure}
\doom 没有中央服务器。所有对等节点都运行各自的游戏逻辑副本，并通过不做预测、且只有在获知所有其他节点动作后才运行一个游戏 tic 的方式保持同步。\\
\par
 这意味着所有节点必须把命令发送给所有其他节点，带来显著的通信开销。
所有节点必须在游戏开始时就齐备。玩家可以离开（他们的化身会留在游戏中但不执行任何动作），但新玩家无法加入。
\pagebreak
 % Each node must send the command generated locally to all other nodes. This means that a machine can simulate the next tic only when ALL nodes involved in the game have send their commands. As a result, the slowest machine dictates the framerate of every players involved. This also meant that all nodes had to run the exact same state machine and run the same version of \doom.\\
% \par





在 \NeXT 上，实现使用了带 Berkeley sockets 的简单 UDP 系统\footnote{Internet Assigned Numbers Authority (IANA) 发布“服务名与传输协议端口号”注册表，其中 UDP 端口 666 为 \doom! 预留。}。在 PC 端情况更复杂。直到 v1.1，引擎都内置了基于 IPX 的局域网支持。为减少通信，Dave Taylor 建议使用 IPX 包节点号 \cw{FF:FF:FF:FF:FF:FF} 进行广播以减少通信量。但事情并未如预期运作。\\
\par
\fq{Doom 使用 IPX 广播包在玩家之间通信。我觉得这在效率上很好，因为四人游戏每帧只需要四个广播包。我对网络的了解仅限于读过的几本书，我天真的理解是：大型网络由路由器连接的小段组成，广播包会被限制在这些小段里。我想我以后会扩展它以允许跨路由器游戏，但暂时可以忽略这个问题。\\
\par
我没意识到有些校园网是由桥接的 IPX 网络构成的，广播包可能经过许多桥接，直到被校园内每台电脑看到。在这些地方，每个玩 LAN Doom 的人都会影响网络上的每台电脑，因为每个广播包都必须被检查，以判断本机是否需要它。几十个 Doom 玩家就能让拥有几千台终端的网络瘫痪。\\
\par
发布后的第二天，我被一通电话吵醒。我迷迷糊糊接起电话，被一名网络管理员痛骂——他找到了我的电话号码，只是为了骂我让他的整个网络崩溃。我迅速修改网络协议，只在游戏发现时使用广播包，游戏过程中改为全互联的定向包（结果四人游戏的包数量增加了 3 倍），但许多管理员仍不得不在桥接设备上增加 Doom 专用规则（以及严厉的警告，要求没人玩这游戏）来处理最初版本造成的问题。}{John Carmack, kotaku.com “Memories Of Doom”}\\ 
\par
随着网络普及，嵌入式 IPX 支持开始显露局限。\\
\par
 与其把更多网络类型的支持“烘焙”进引擎，不如移除 IPX 代码，把网络重构为“网络驱动”的概念。
\pagebreak



% \par
% \begin{verbatim}

%  IPX addressing: 12 bytes structured as follow:

%    Network         Node        Socket
% |-----------|-----------------|-----|
%  XX XX XX XX XX XX XX XX XX XX XX XX 

% \end{verbatim}


\subsection{PC 网络驱动}
在该模型中，引擎处理一个名为 \cw{doomcom\_t} 的数据结构（详见第 \pageref{doomcom_t.c} 页），它位于共享内存中。收发包通过中断完成。这一切协同的方式是一个只能在缺乏正确内存保护的系统上实现的绝妙黑客技巧。\\
\par
一个“加载器”先启动，并把自己安装为中断处理器。然后它用特殊参数 \cw{-net X} 启动 \cw{DOOM.EXE}，其中 X 是加载器变量 \cw{doomcom\_t} 的 RAM 地址。引擎直接把该参数转换为地址（\cw{(doomcom\_t*)(atoi(param))}）来访问结构体字段。从那时起，中断处理器就充当网络驱动。\\
\par

\fakedosoutput{doomnet.c}
\par
 到这一步，引擎已具备通用方式进行通信所需的一切。它读写 \cw{doomcom\_t} 并通过中断号（也在 \cw{doomcom\_t} 中提供）调用处理器。\\
\par
\drawing{net_drivers}{}
\par
\vspace{-10pt}
 图 \ref{net_drivers} 总结了步骤。\cw{IPXSETUP.EXE} 先启动 \circled{1}。加载器在软件中断向量表中注册自己。注册后，\cw{IPXSETUP.EXE} 启动 \cw{DOOM.EXE} 并把 \cw{doomcom\_t} 变量地址作为整数传入 \circled{2}。之后在游戏过程中 \circled{3}，\cw{DOOM.EXE} 读写 \cw{doomcom\_t} 的 \cw{payload} 字段，并通过 \cw{intnum} 字段中的中断触发传输。这会触发 \circled{4} 的 \doom{} 网络驱动与网卡驱动通信。网卡驱动与物理网卡之间的实际硬件交互发生在 \circled{5}。




两个网络驱动随游戏发布：\cw{IPXSETUP.EXE} 支持 IPX 上最多四个节点，\cw{SERSETUP.EXE} 支持通过串口线或调制解调器连接两名玩家。DWANGO 公司提供了自己的驱动（\cw{DWANGO.EXE}），允许通过调制解调器连接 2 个以上节点。





\vspace{-5pt}
\subsection{实现}
为了进行网络 I/O，核心只与网络子系统提供的三个元素打交道。\\
\par
 \begin{figure}[H]
\centering  
\begin{tabularx}{\textwidth}{ L{0.6}  L{1.4}}
  \toprule
  \textbf{元素} &  \textbf{用途}\\

  \toprule 
   I\_InitNetwork & 初始化网络子系统。\\
   doomcom\_t doomcom & 包含输入与输出数据的共享结构。\\
   I\_NetCmd & 根据信息 \doomcom 发送/接收数据。\\
   \toprule
\end{tabularx}
\caption{\doom{} 网络子系统接口}
\end{figure}


\vspace{-10pt}
在 PC 上进行多人联机时，网络初始化只需获取中断处理器的地址。注意最后一行将 \cw{atoi} 的返回值转换为指针——以今天的眼光看相当随意。\\
\par

\ccode{I_InitNetwork.c}









有了对 \cw{doomcom} 变量的访问，就可以访问 \cw{intnum} 字段，其中保存了 \doom{} 网络驱动注册的软中断号。当调用（通过 \cw{int} 指令）时，它会中断 \doom{}，让网卡的网络驱动把网络数据复制进/出 \cw{doomcom}。\\



\ccode{doomcom_t.c} \label{doomcom_t.c} \\ 
\par
\vspace{-10pt}
这些字段不言自明，但请注意 \cw{command}，它告诉驱动要发送还是接收数据。\cw{id} 字段允许 \doom{} 验证该地址确实是有效的网络驱动。\cw{ticcmd\_t} 的 \cw{payload} 在第 \pageref{cmd_t_type} 页已介绍。



在高层上，\doom{} 的核心使用名为 \cw{NetUpdate} 的中心函数来进行所有 I/O。注意它会在循环中被调用，直到收齐所有节点的 ticcmd，只有菜单还能继续响应。除了菜单，其他一切都会暂停。\\
\par
\ccode{net_loop_wait.c}\\
\par
引擎无法推断并继续推进游戏，这成为问题，因为所有机器最终都以最低公共帧率运行。为缓解此问题，引擎采用了一种奇特的“线程复用”方式，在一帧内多次调用 \cw{NetUpdate}。通常不少于 8 次。\\
\par
\ccode{R_RenderPlayerView_withupdates.c}



既然无法期望网络介质保证包投递，引擎实现了否定确认机制（negative acknowledgment）：每个对等节点（也叫 node）都会跟踪包序号。如果收到一个包，但其序号表明丢失了此前的包，则该节点请求重发缺失的命令。这意味着每个节点在发送后不能丢弃命令。\\
\par
这种重发机制是最后的手段，应该尽可能避免。因此数据包不仅包含当前命令，还包含上一次命令（如果设置了 \cw{extratics} 字段）。\\




\vspace{-15pt}
\subsection{DeathManager}
鉴于配置网络游戏的命令行参数相当复杂，因此提供了多个工具。最初玩家可使用 \cw{SETUP.EXE}。1994 年 12 月，id Software 推出更易用的 \cw{DM.EXE}（DeathManager）。\\
\par
\cfullimage{DeathManagerv1-2.png}{Death Manager 1.2 界面。}
\par
\vspace{-10pt}
在“旧版死亡竞赛”模式中，武器被拾取后不会消失，弹药和强化道具也不会刷新。1994 年 7 月，“Deathmatch 2.0” 引入了规则变化：所有物品拾取后会消失，并在 $\overline{50}$ 秒后重生。\\
\par









\trivia{\doom{} 的开拓性如此之强，以至于它的 UDP 端口号（666）至今仍在多数路由器和 Windows 上被保留（文件 \cw{C:\textbackslash Windows\textbackslash System32\textbackslash drivers\textbackslash etc}）。官方 IPX socket 号（0x869C）也仍在 Novell 的“知名静态 IPX sockets”表中。}

\fullimage{coop.png}\\
\par
合作模式很有趣（上图），但更加血腥的死亡竞赛（下图）同样精彩。\\
\par
\fullimage{deathmatch.png}
