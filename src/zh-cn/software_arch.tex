\section{架构}
在深入代码与结构之前，让我们先花点时间理解 id 的开发者是如何工作的。在 \doom 之前，所有工作都在 PC 上完成：代码编写并编译，生成的可执行文件在同一台机器上运行。随着 \NeXT 工作站加入流程，工作方式必须改变。\\
\par
一名开发者拥有两台机器：一台 \NeXT 工作站和一台 PC。所有编写工作都在 \NeXTns{} 上完成。代码用 \cw{TextEdit.app} 编写，用 \cw{gcc} 编译，用 \cw{ld} 链接，可执行文件在 NeXTstation 上运行。在 Unix 系统上工作的最大优势是稳定性。开发者不会因为 IDE 崩溃而丢失工作\footnote{使用 Borland C++ 时，崩溃几乎是家常便饭（来源：与 John Carmack 的通信）。}。\\
\par
当开发者对结果满意后，他会切换到第二台机器。为了做到这一点，他真的会把椅子滚到 PC 边上，那里通过 NFS 挂载了 \NeXT 工作站的硬盘。PC 再次编译同样的源代码\footnote{带有一些平台相关差异。}，使用 Watcom 工具链、\cw{WCC386.EXE} 编译器和 \cw{WLINK.EXE} 链接器，生成 \cw{DOOM.EXE}。 \\n\par
在这个设置中，PC 被降格为“只负责”运行游戏并评估性能。PC 的硬盘实际上只用于引导系统并存放 \cw{WATCOM} 编译器。其他一切（包括 \cw{DOOM.EXE} 可执行文件）都存储在 \NeXT 的 SCSI 硬盘上。\\
\par
这种工作方式有显著障碍。首先，DOS 程序可以直接访问硬件，而 NeXT 进程必须使用“官方” API。其次也是最重要的，两台机器的字节序不同。PC 运行的是 Intel CPU（小端序），而 \NeXT 机器使用的是大端序的 Motorola 68040 CPU。\\
\vspace{2mm}
\par
\begin{figure}[H]
\centering
\scaleddrawing{0.8}{dev_setup}{\protect\NeXT HDD 用户主目录被挂载到 DOS 机器作为 Z 盘。}
\end{figure}
\par



\subsection{解决字节序}
字节序（endianness）一词由 Danny Cohen 在文章《On holy wars and a plea for peace》中提出。他借《格列佛游记》中关于煮鸡蛋从大端还是小端敲开的内战讽刺，来类比 CPU 厂商之间两种思路：有的希望字节从左到右排列，有的希望从右到左排列。双方都认为自己的方式更好。\\
\par
在这场战争中，程序员付出了代价，但没有哪一方有促成和平的动机。



字节内的位序达成了一致，但在更大结构（如 16 位的 short 或 32 位的 int）中的字节顺序，会因厂商内部架构而不同。字节流 \cw{0x12}、\cw{0x34}、\cw{0x56}、\cw{0x78} 可以有两种解释。在 Intel 小端机器上，它会变成 \cw{0x78563412}；在 Motorola 大端机器上，它会变成 \cw{0x12345678}。\\
\par
\drawing{endianness}{微小的连线差异在 CPU 字之间形成了难以跨越的边界}
\par
在游戏引擎层面，问题通过一个简单的宏来间接解决\footnote{截至 2018 年，这场圣战似乎终于结束。Intel、AMD 与 ARM 的小端派胜出。}。从磁盘读取时，引擎始终使用 \cw{LONG} 或 \cw{SHORT} 宏来解释数据。\\
\par
\ccode{big_little_endian.c}
\par
\ccode{LongSwap.c}
\par
尽管 \doom{} 首先在 \NeXT 上开发，但该平台有意把自己置于劣势。因为玩家会使用 MS-DOS，数据以小端序存储，因此 \cw{LONG} 和 \cw{SHORT} 宏在消费级 Intel 硬件上会变成零指令开销。


\subsection{解决 API}
适配不同操作系统的需求更具挑战。解决方案是提供一个平台无关的“核心”。进行 I/O 时，核心会调用目标平台特定的子系统。\\
\par
\begin{figure}[H]
\centering
\includegraphics[width=.5\textwidth]{drawings/doom_arch.pdf}
\caption{\doom{} 的核心与平台相关 I/O 系统。注意它与操作系统设计的相似性。}
\end{figure}
\par
在视频系统的情况下，MS-DOS 上会使用 VGA 硬件，而 \NeXT 上使用 \cw{NSWindow} API。天真的实现会用函数指针作为间接层来分发每个 I/O 调用。更好的方案是利用 C 的链接阶段。\\
\par
构建 C 程序时，所有编译单元（\cw{.c} 文件）独立编译。在编译阶段结束时，所有 \cw{.c} 文件都会变成对象（\cw{.o}）文件。对象文件可能相互引用，但由于独立生成，它们会留下称为“未解析符号”的“空洞”。为了生成可执行文件，把所有对象交给链接器，链接器会识别所有对象中的未解析符号并补齐这些空洞。\\
 \par
 以核心中的 \cw{s\_sound.c} 为例，查看 \cw{s\_sound.o} 可以看到这个翻译单元使用了 \cw{I\_PlaySong} 与 \cw{I\_StartSound} 等函数，它们定义在平台特定的声音系统中。\pagebreak

使用 \cw{nm} 查看未定义符号即可看到对象文件的“空洞”。\\
 \par
\tcode{s_sound_linker.txt}
\par
链接器完成后，不再有未解析符号。最终可执行文件就可以运行了。\\
\par
\drawing{linking}{\doom{} 的大部分代码是共享的。只有少量文件与平台相关。}




\pagebreak
\drawing{doom_code_arch}{\doom{} 源代码架构}
\par
白色部分为核心组件，灰色部分为需要平台特定代码的 I/O 系统。在 DOS 上，它们由 6 个额外文件提供：\cw{i\_main.c}、\cw{i\_ibm.c}、\cw{planar.asm}、\cw{i\_ibm\_a.asm}、\cw{i\_sound.c}、\cw{i\_cyber.c}。\\








\fullimage{Doom_build_NeXTStep.png}
\smallfakedosoutput{dos_compilation2.txt}
